{
  "title": "drums",
  "bpm": 100,
  "tracks": [
    {
      "title": "drums/track.js",
      "value": "export default async c => {\n  const [\n    kick,\n    snare,\n    clap,\n    cow,\n    ltom,\n    mtom,\n    htom,\n    ch,\n    oh, \n  ] = await Promise.all([\n    c.buf({id:'kick',len:c.br,ch:1}),\n    c.buf({id:'snare',len:c.br,ch:1}),\n    c.buf({id:'clap',len:c.br,ch:1}),\n    c.buf({id:'cow',len:c.br,ch:1}),\n    c.buf({id:'ltom',len:c.br,ch:1}),\n    c.buf({id:'mtom',len:c.br,ch:1}),\n    c.buf({id:'htom',len:c.br,ch:1}),\n    c.buf({id:'ch',len:c.br,ch:1}),\n    c.buf({id:'oh',len:c.br,ch:1}),\n  ])\n  \n  await Promise.all([\n    c.src('./kick.js',{buffer:kick}),\n    c.src('./snare.js',{buffer:snare,hz:190,snapVol:.5}),\n    c.src('./clap.js',{buffer:clap,cut:600,res:3.5}),\n    c.src('./cowbell.js',{buffer:cow}),\n    c.src('./tom.js',{id:'ltom',buffer:ltom,hz:190}),\n    c.src('./tom.js',{id:'mtom',buffer:mtom,hz:470}),\n    c.src('./tom.js',{id:'htom',buffer:htom,hz:590}),\n    c.src('./hihat.js',{id:'ch',buffer:ch,decay:7,seed:37,cut:15000,res:2.9}),\n    c.src('./hihat.js',{id:'oh',buffer:oh,decay:5,seed:6666,cut:3100,res:.7}),\n  ])\n  \n  const patterns = {\n    kick:  ['1 1 1 1', 1],\n    ch:    ['.13 .15 0 .47', 1/4],\n    oh:    ['- 1', 1/2],\n    clap:  ['- 1', 1],\n    snare: ['-  - .27 -  -  -  -  -  -  -  -  -  -  -  -  1', 1/4],\n    cow:   ['-  -  - .4  -  1  - .3', 1/4],\n    ltom:  ['-  4  - .8  -  - .8  -', 1/4],\n    mtom:  ['-  - .2  -  -  1  -  -', 1/4],\n    htom:  ['-  -  -  -  -  -  - .7', 1/4]\n  }    \n\n  parse(patterns)\n\n  return c => {\n    return (\n      play(c, kick[0], patterns.kick)\n    + play(c, ch[0].subarray(0,700), patterns.ch)*1.5\n    + play(c, oh[0].subarray(0,3500), patterns.oh)*.28\n    + play(c, clap[0].subarray(0,4180), patterns.clap)*.85\n    + play(c, snare[0], patterns.snare)*.7\n    // + play(c, cow[0], patterns.cow)*.2\n    + play(c, ltom[0], patterns.ltom)*.1\n    + play(c, mtom[0], patterns.mtom)*.2\n    + play(c, htom[0], patterns.htom)*.3\n    )\n  }\n}\n\nconst parse = patterns => {\n  for (const pattern of Object.values(patterns)) {\n    const vols = pattern[0].replace(/ {1,}/g, ' ').trim().split(' ')\n      .map(n => parseFloat(n))\n      .map(n => toFinite(n))\n    pattern[0] = vols\n  }\n}\n\nconst play = (c, source, [vols, tempo], repeat = false) => {  \n  const len = c.br * 4\n  const total = vols.length\n  \n  const vol = vols[(c.b/tempo)%total|0]\n  \n  const pos = (c.p%(c.br*tempo)|0)\n\n  if (repeat) {\n    return source[pos%source.length] * vol\n  } else {\n    return (source[pos]??0) * vol\n  }  \n}\n\nconst toFinite = n => Number.isFinite(n) ? n : 0",
      "vol": 0.9933333333333333
    },
    {
      "title": "piano/track.js",
      "value": "import tri from './tri.js'\nimport Lowpass from './lowpass.js'\nexport default async c => {\n  const lp = await Lowpass(c)\n  return (c, { hz = 480, chord = [16/9,32/27,4/3] }=c) => {\n    let x = \n      tc(c, { hz })\n    + chord\n      .map(ratio => tc(c, { hz: hz * ratio }))\n      .reduce((p, n) => p + n, 0)\n\n    x = lp({ x }, { a: .45 })\n    \n    let h = \n      tri(c, { hz: 800 })\n    + tri(c, { hz: 505 })\n    \n    h = h * Math.exp(-(c.k)*60)\n    x += h\n\n    return x/(1+chord.length) \n    * Math.exp(-((1/2+c.k)%1) * 1) \n    * Math.min(1,(c.p/20000%1))\n  }\n}\n\nconst tc = (c, { hz }) => {\n  return (\n    tri(c, { hz }) \n  + tri(c, { hz: hz*1.0015 }) \n  + tri(c, { hz: hz*1.0035 })\n  ) / 3\n}",
      "vol": 0.9933333333333333
    },
    {
      "title": "303/track.js",
      "value": "import DiodeFilter from './diodefilter.js'\nimport Wavetable from './wavetable.js'\n\nconst clip = (x, amt=.5) => x / ((amt || 1) + Math.abs(x))\n\nconst slide = (c, measure, speed, seq) => {\n  var pos = (c.b / measure / 2) % seq.length;\n  var now = pos | 0;\n  var next = now + 1;\n  var alpha = pos - now;\n  if (next == seq.length) next = 1;\n  return seq[now] \n    + ((seq[next] - seq[now]) * Math.pow(alpha, speed));\n}\n\nexport default async c => {\n  const lpf = new DiodeFilter()\n  const saw = await Wavetable(c, {\n    osc: './ramp.js',\n    alias: false \n  })\n  let x = 0.0\n  return (c, { melody = [\n    50,40,61,70,\n    // 50,150,61,70,\n    // 50,150,61,70,\n    // 50,150,61,170,\n  ] }) => {\n    x = saw(c, { \n        hz: slide(c, 1/4, 6, melody)  \n        //[(c.b)%4|0] * (1)\n      })\n      * Math.exp(-((c.b*2)%1) * 2)\n      \n    x = lpf\n      .hpf(0.00021)\n      .cut(Math.max(0.071,\n          -0.12\n          + (Math.sin(c.b*.25*Math.PI*2)/3+1) *\n          0.15\n          //-0.06\n        + (0.021 * Math.sin(c.b*3/9*Math.PI*2))\n        + (Math.exp(-((c.b*2)%1) * 1) * 0.06)\n        + ((1-Math.exp(-((c.b)%1) * 1)) * 0.03)\n      ))\n      .res(0.375)\n      .run(x)\n    return clip(x*1.3,.12)*1\n  }\n}",
      "vol": 0.8733333333333333
    }
  ],
  "modules": [
    {
      "title": "drums/saw.js",
      "value": "export default (c, { hz = 50 }) =>\n  1 - 2 * (c.s % (1 / hz)) * hz"
    },
    {
      "title": "drums/sin.js",
      "value": "export default (c, { hz = 200 }) => \n  Math.sin(c.s * hz * 2 * Math.PI)"
    },
    {
      "title": "drums/lowpass.js",
      "value": "export default async c => {\n  let y = 0\n  return (c, { a = .5 }) =>\n    y += (c.x - y) * a\n}"
    },
    {
      "title": "drums/kick.js",
      "value": "import Wavetable from './wavetable.js'\nexport default async c => {\n  const sin = await Wavetable(c, { osc: './sin.js' })\n  return (c, {\n    hz = 200,\n    pitchDecay = 15,\n    volDecay = 15\n  }) => {\n    if (c.p === 0) sin.setPhase(0)\n    return sin(c, { \n      hz: 200 * Math.exp(-c.t * pitchDecay)\n    }) * Math.exp(-c.t * volDecay)\n  }\n}"
    },
    {
      "title": "drums/wavetable.js",
      "value": "export default async (c, {\n  osc='./saw.js',\n  len=1024,\n  sync='sr',\n  alias=false\n}=c) => {\n  let coeff = len/c[sync]\n  let pos = 0.0\n  let index = 0\n  let alpha = 0.0\n  let next = 0.0\n  let curr = 0.0\n  let buffer = await c.buf({len,ch:1})\n  let table = (await c.src(osc,{\n    n:0,\n    buffer,\n    ig:sync[0],\n    hz:c[sync]/len\n  }))[0]\n  let fn\n  if (alias) {\n    fn = (c,{hz=64}=c) => {\n      index = Math.floor(pos)\n      alpha = pos-index\n      next = table[index+1]??table[0]\n      curr = table[index]\n      pos += hz*coeff \n      pos %= len\n      return curr+(next-curr)*alpha\n    }\n  } else {\n    fn = (c,{hz=64}=c) => {\n      index = Math.floor(pos)\n      pos += hz*coeff\n      pos %= len\n      return table[index]\n    }\n  }\n  fn.setPhase = x => pos = x\n  return fn\n}"
    },
    {
      "title": "drums/noise.js",
      "value": "export default (c, { seed = 123456 }) => {\n  let x = Math.sin(seed+c.p)*100000\n  return (x - Math.floor(x)) * 2 - 1\n}"
    },
    {
      "title": "drums/snare.js",
      "value": "import Wavetable from './wavetable.js'\nimport noise from './noise.js'\nexport default async c => {\n  const sin = await Wavetable(c, { osc: './sin.js' })\n  let tone = 0.0\n  let snap = 0.0\n  return (c, {\n    hz = 160,\n    volDecay = 33,\n    seed = 1337,\n    snapVol = .20,\n    snapDecay = 35\n  }) => {\n    if (c.p === 0) sin.setPhase(0)\n    tone = sin(c, { hz })\n      * Math.exp(-c.t * volDecay)\n    snap = noise(c, { seed })\n      * Math.exp(-c.t * snapDecay)\n      * snapVol\n    return tone + snap\n  }\n}"
    },
    {
      "title": "drums/tom.js",
      "value": "import Wavetable from './wavetable.js'\nimport noise from './noise.js'\nexport default async c => {\n  const sin = await Wavetable(c, { osc: './sin.js' })\n  let tone = 0.0\n  let snap = 0.0\n  return (c, {\n    hz = 80,\n    transAmt = 60,\n    transDecay = 8,\n    volDecay = 10,\n    seed = 1337,\n    snapVol = .005,\n    snapDecay = 35,\n  }) => {\n    if (c.p === 0) sin.setPhase(0)\n    tone = sin(c, { \n      hz: hz + (transAmt * Math.exp(-c.t * transDecay))\n    })* Math.exp(-c.t * volDecay)\n    snap = noise(c, { seed })\n      * Math.exp(-c.t * snapDecay)\n      * snapVol\n    return tone + snap\n  }\n}"
    },
    {
      "title": "drums/pulse.js",
      "value": "export default (c, { hz = 50, width = 1.05 }) =>\n  (c.s*hz % 1/hz < 1/hz/2*width) * 2 - 1"
    },
    {
      "title": "drums/cowbell.js",
      "value": "import pulse from './pulse.js'\nexport default async c => {\n  let hz = [555, 835, 1370, 1940]\n  let x1, x2, x3, x4\n  return c => {\n    x1 = pulse(c, { hz: hz[0], width: .435 })\n    x2 = pulse(c, { hz: hz[1], width: .9 })\n    x3 = pulse(c, { hz: hz[2], width: 2.0 })*.15\n    x4 = pulse(c, { hz: hz[3], width: 0.6 })*.15\n    return (x1 + x2 + x3 + x4)/4 * Math.exp(-c.t * 20)\n  }\n}"
    },
    {
      "title": "drums/clap.js",
      "value": "import Filter, { bandpass } from './biquad.js'\nimport noise from './noise.js'\nexport default async c => {\n  let filter = await Filter(c)\n  let seed = [500, 450, 500, 8200]\n  let x, x1, x2, x3, x4\n  return (c, { cut = 1200, res = 1 }=c) => {\n    x1 = noise(c, { seed: seed[0] })\n    x2 = noise(c, { seed: seed[1] })\n    x3 = noise(c, { seed: seed[2] })\n    x4 = noise(c, { seed: seed[3] })\n    \n    x1 *= Math.exp(-(c.t%1) * 110)\n    x2 *= Math.exp(-((c.t+.99)%1) * 110)*1.25\n    x3 *= Math.exp(-((c.t+.975)%1) * 110)*.9\n    x4 *= Math.exp(-(c.t) * 7)*.10\n    \n    x = x1 + x2 + x3 + x4\n    x = filter({ x }, bandpass(c, { cut, res }))\n    return x*3\n  }\n}"
    },
    {
      "title": "drums/biquad.js",
      "value": "const freqToFloat = ({ sampleRate }, freq = 500) => \n  freq / (sampleRate / 2)\n\nexport default async () => {\n  let x = 0.0, x1 = 0.0, x2 = 0.0\n  let y = 0.0, y1 = 0.0, y2 = 0.0\n\n  return (c, [b0, b1, b2, a1, a2]) => {\n    x = c.x\n\n    y = b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2\n\n    x2 = x1\n    x1 = x\n\n    y2 = y1\n    y1 = y\n\n    return y\n  }\n}\n\nexport const bandpass = ({ sampleRate }, { cut = 1000, res = .5 } = {}) => {\n  cut = freqToFloat({ sampleRate }, cut)\n\n  let b0 = 0.0, b1 = 0.0, b2 = 0.0\n  let a1 = 0.0, a2 = 0.0\n\n  if (cut > 0 && cut < 1) {\n    if (res > 0) {\n      const u = Math.PI * cut\n      const a = Math.sin(u) / (2 * res)\n      const k = Math.cos(u)\n      const ia0 = 1 / (1 + a)\n\n      b0 = a * ia0\n      b1 = 0\n      b2 = -a * ia0\n      a1 = -2 * k * ia0\n      a2 = (1 - a) * ia0\n    } else {\n      b0 = b1 = b2 = a1 = a2 = 0\n    }\n  } else {\n    b0 = b1 = b2 = a1 = a2 = 0\n  }\n\n  return [b0, b1, b2, a1, a2]\n}\n\nexport const highpass = ({ sampleRate }, { cut = 1000, res = .5 } = {}) => {\n  cut = freqToFloat({ sampleRate }, cut)\n\n  let b0 = 0.0, b1 = 0.0, b2 = 0.0\n  let a1 = 0.0, a2 = 0.0\n\n  if (cut >= 1) {\n    b0 = b1 = b2 = a1 = a2 = 0\n  } else if (cut <= 0) {\n    b0 = 1\n    b1 = b2 = a1 = a2 = 0\n  } else {\n    res = Math.max(0, res)\n    const g = Math.pow(10.0, 0.05 * res)\n    const d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) * 0.5)\n\n    const u = Math.PI * cut\n    const s = 0.5 * d * Math.sin(u)\n    const b = 0.5 * (1 - s) / (1 + s)\n    const k = (0.5 + b) * Math.cos(u)\n    const a = 0.25 * (0.5 + b + k)\n\n    b0 = 2 * a\n    b1 = -4 * a\n    b2 = b0\n    a1 = 2 * -k\n    a2 = 2 * b\n  }\n\n  return [b0, b1, b2, a1, a2]\n}"
    },
    {
      "title": "drums/hihat.js",
      "value": "import Filter, { highpass } from './biquad.js'\nimport noise from './noise.js'\nexport default async c => {\n  let filter = await Filter(c)\n  let x\n  return (c, {\n    seed=8026, \n    decay=20, \n    cut=4500, \n    res=.3 \n  }=c) => {\n    x = noise(c, { seed })\n    x *= Math.exp(-c.t * decay)\n    x = filter({ x }, highpass(c, { cut, res }))\n    return x\n  }\n}"
    },
    {
      "title": "piano/saw.js",
      "value": "export default (c, { hz = 50 }) =>\n  1 - 2 * (c.s % (1 / hz)) * hz"
    },
    {
      "title": "piano/sin.js",
      "value": "export default (c, { hz = 200 }) => \n  Math.sin(c.s * hz * 2 * Math.PI)"
    },
    {
      "title": "piano/lowpass.js",
      "value": "export default async c => {\n  let y = 0\n  return (c, { a = .5 }) =>\n    y += (c.x - y) * a\n}"
    },
    {
      "title": "piano/wavetable.js",
      "value": "export default async (c, {\n  osc='./saw.js',\n  len=1024,\n  sync='sr',\n  alias=false\n}=c) => {\n  let coeff = len/c[sync]\n  let pos = 0.0\n  let index = 0\n  let alpha = 0.0\n  let next = 0.0\n  let curr = 0.0\n  let buffer = await c.buf({len,ch:1})\n  let table = (await c.src(osc,{\n    n:0,\n    buffer,\n    ig:sync[0],\n    hz:c[sync]/len\n  }))[0]\n  let fn\n  if (alias) {\n    fn = (c,{hz=64}=c) => {\n      index = Math.floor(pos)\n      alpha = pos-index\n      next = table[index+1]??table[0]\n      curr = table[index]\n      pos += hz*coeff \n      pos %= len\n      return curr+(next-curr)*alpha\n    }\n  } else {\n    fn = (c,{hz=64}=c) => {\n      index = Math.floor(pos)\n      pos += hz*coeff\n      pos %= len\n      return table[index]\n    }\n  }\n  fn.setPhase = x => pos = x\n  return fn\n}"
    },
    {
      "title": "piano/noise.js",
      "value": "export default (c, { seed = 123456 }) => {\n  let x = Math.sin(seed+c.p)*100000\n  return (x - Math.floor(x)) * 2 - 1\n}"
    },
    {
      "title": "piano/pulse.js",
      "value": "export default (c, { hz = 50, width = 1.05 }) =>\n  (c.s*hz % 1/hz < 1/hz/2*width) * 2 - 1"
    },
    {
      "title": "piano/biquad.js",
      "value": "const freqToFloat = ({ sampleRate }, freq = 500) => \n  freq / (sampleRate / 2)\n\nexport default async () => {\n  let x = 0.0, x1 = 0.0, x2 = 0.0\n  let y = 0.0, y1 = 0.0, y2 = 0.0\n\n  return (c, [b0, b1, b2, a1, a2]) => {\n    x = c.x\n\n    y = b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2\n\n    x2 = x1\n    x1 = x\n\n    y2 = y1\n    y1 = y\n\n    return y\n  }\n}\n\nexport const bandpass = ({ sampleRate }, { cut = 1000, res = .5 } = {}) => {\n  cut = freqToFloat({ sampleRate }, cut)\n\n  let b0 = 0.0, b1 = 0.0, b2 = 0.0\n  let a1 = 0.0, a2 = 0.0\n\n  if (cut > 0 && cut < 1) {\n    if (res > 0) {\n      const u = Math.PI * cut\n      const a = Math.sin(u) / (2 * res)\n      const k = Math.cos(u)\n      const ia0 = 1 / (1 + a)\n\n      b0 = a * ia0\n      b1 = 0\n      b2 = -a * ia0\n      a1 = -2 * k * ia0\n      a2 = (1 - a) * ia0\n    } else {\n      b0 = b1 = b2 = a1 = a2 = 0\n    }\n  } else {\n    b0 = b1 = b2 = a1 = a2 = 0\n  }\n\n  return [b0, b1, b2, a1, a2]\n}\n\nexport const highpass = ({ sampleRate }, { cut = 1000, res = .5 } = {}) => {\n  cut = freqToFloat({ sampleRate }, cut)\n\n  let b0 = 0.0, b1 = 0.0, b2 = 0.0\n  let a1 = 0.0, a2 = 0.0\n\n  if (cut >= 1) {\n    b0 = b1 = b2 = a1 = a2 = 0\n  } else if (cut <= 0) {\n    b0 = 1\n    b1 = b2 = a1 = a2 = 0\n  } else {\n    res = Math.max(0, res)\n    const g = Math.pow(10.0, 0.05 * res)\n    const d = Math.sqrt((4 - Math.sqrt(16 - 16 / (g * g))) * 0.5)\n\n    const u = Math.PI * cut\n    const s = 0.5 * d * Math.sin(u)\n    const b = 0.5 * (1 - s) / (1 + s)\n    const k = (0.5 + b) * Math.cos(u)\n    const a = 0.25 * (0.5 + b + k)\n\n    b0 = 2 * a\n    b1 = -4 * a\n    b2 = b0\n    a1 = 2 * -k\n    a2 = 2 * b\n  }\n\n  return [b0, b1, b2, a1, a2]\n}"
    },
    {
      "title": "piano/tri.js",
      "value": "export default (c, { hz = 200 }) =>\n  Math.abs(1 - (2 * c.s * hz) % 2) * 2 - 1"
    },
    {
      "title": "303/saw.js",
      "value": "export default (c, { hz = 50 }) =>\n  1 - 2 * (c.s % (1 / hz)) * hz"
    },
    {
      "title": "303/ramp.js",
      "value": "export default (c, { hz = 50 }) =>\n  2 * (c.s % (1 / hz)) * hz - 1"
    },
    {
      "title": "303/sqr.js",
      "value": "export default (c, { hz = 50 }) =>\n  (c.s*hz % 1/hz < 1/hz/2) * 2 - 1"
    },
    {
      "title": "303/pulse.js",
      "value": "export default (c, { hz = 50, width = 1.05 }) =>\n  (c.s*hz % 1/hz < 1/hz/2*width) * 2 - 1"
    },
    {
      "title": "303/diodefilter.js",
      "value": "const clip = (x, amt=.5) => x / ((amt || 1) + Math.abs(x))\n\nexport default DiodeFilter\n\nfunction DiodeFilter(){\n  if (!(this instanceof DiodeFilter)) return new DiodeFilter();\n  this.k = 0;\n  this.A = 0;\n  this.z = new Float32Array([0,0,0,0,0]);\n  this.ah;\n  this.bh;\n  this.fc;\n  this.res(0);\n  this.hpf(0.5);\n  this.cut(0.5);\n}\n\nDiodeFilter.prototype.hpf = function(fc){\n  var K = fc * Math.PI;\n  this.ah = (K - 2) / (K + 2);\n  this.bh = 2 / (K + 2);\n  return this;\n};\n\nDiodeFilter.prototype.reset = function(){\n  if (this.k < 17) this.z = new Float32Array([0,0,0,0,0]);\n};\n\nDiodeFilter.prototype.res = function(q){\n  this.k = 20 * q;\n  this.A = 1 + 0.5 * this.k;\n  return this;\n};\n\nDiodeFilter.prototype.cut = function(cutoff){\n  cutoff = (cutoff * cutoff);\n  this.fc = cutoff <= 0\n    ? 0.02\n    : (cutoff >= 1.0 ? 0.999 : cutoff);\n  return this;\n};\n\nDiodeFilter.prototype.run = function(x){\n  var a = Math.PI * this.fc;\n  a = 2 * Math.tan(0.5*a); // dewarping, not required with 2x oversampling\n  var ainv = 1 / a;\n  var a2 = a*a;\n  var b = 2*a + 1;\n  var b2 = b*b;\n  var c = 1 / (2*a2*a2 - 4*a2*b2 + b2*b2);\n  var g0 = 2*a2*a2*c;\n  var g = g0 * this.bh;\n\n  // current state\n  var s0 = (a2*a*this.z[0] + a2*b*this.z[1] + this.z[2]*(b2 - 2*a2)*a + this.z[3]*(b2 - 3*a2)*b) * c;\n  var s = this.bh*s0 - this.z[4];\n\n  // solve feedback loop (linear)\n  var y5 = (g*x + s) / (1 + g*this.k);\n\n  // input clipping\n  var y0 = clip(x - this.k*y5);\n  y5 = g*y0 + s;\n\n  // compute integrator outputs\n  var y4 = g0*y0 + s0;\n  var y3 = (b*y4 - this.z[3]) * ainv;\n  var y2 = (b*y3 - a*y4 - this.z[2]) * ainv;\n  var y1 = (b*y2 - a*y3 - this.z[1]) * ainv;\n\n  // update filter state\n  this.z[0] += 4*a*(y0 - y1 + y2);\n  this.z[1] += 2*a*(y1 - 2*y2 + y3);\n  this.z[2] += 2*a*(y2 - 2*y3 + y4);\n  this.z[3] += 2*a*(y3 - 2*y4);\n  this.z[4] = this.bh*y4 + this.ah*y5;\n\n  return this.A*y4;\n};"
    },
    {
      "title": "303/wavetable.js",
      "value": "export default async (c, {\n  osc='./saw.js',\n  len=1024,\n  sync='sr',\n  alias=false\n}=c) => {\n  let coeff = len/c[sync]\n  let pos = 0.0\n  let index = 0\n  let alpha = 0.0\n  let next = 0.0\n  let curr = 0.0\n  let buffer = await c.buf({len,ch:1})\n  let table = (await c.src(osc,{\n    n:0,\n    buffer,\n    ig:sync[0],\n    hz:c[sync]/len\n  }))[0]\n  if (alias) {\n    return (c,{hz=64}=c) => {\n      pos += hz*coeff \n      pos %= len\n      index = Math.floor(pos)\n      alpha = pos-index\n      next = table[index+1]??table[0]\n      curr = table[index]\n      return curr+(next-curr)*alpha\n    }\n  } else {\n    return (c,{hz=64}=c) => {\n      pos += hz*coeff\n      pos %= len\n      index = Math.floor(pos)\n      return table[index]\n    }\n  }\n}"
    }
  ]
}